<!DOCTYPE html>
<html lang="ja">

<head>
	<meta charset="UTF-8">
	<title>シューティングゲーム（ボス追加版）</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		/* --- レイアウト --- */
		body {
			margin: 0;
			background: #000;
			display: flex;
			justify-content: flex-start;
			align-items: flex-start;
			height: 100vh;
			overflow: hidden;
			position: relative;
		}

		canvas {
			background: #111;
			display: block;
			touch-action: none;
			margin-top: 0;
		}

		/* カウントダウン中央表示 */
		#countdown {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: #fff;
			font-size: 80px;
			font-family: Arial, sans-serif;
			text-align: center;
		}

		/* 中央ボタン（リトライ／報酬 共通スタイル） */
		button.actionBtn {
			font-size: 20px;
			padding: 15px 30px;
			border: none;
			border-radius: 10px;
			cursor: pointer;
			background: #66ccff;
			color: #fff;
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			display: none;
		}
	</style>
</head>

<body>
	<canvas id="gameCanvas" width="400" height="600"></canvas>
	<div id="countdown"></div>
	<button id="retryBtn" class="actionBtn">リトライ</button>
	<button id="rewardBtn" class="actionBtn">報酬をゲット</button>

	<script>
		/* ========== 初期設定 ========== */
		const canvas = document.getElementById("gameCanvas");
		const ctx = canvas.getContext("2d");
		const countdownEl = document.getElementById("countdown");
		const retryBtn = document.getElementById("retryBtn");
		const rewardBtn = document.getElementById("rewardBtn");

		let player, bullets = [], enemies = [], enemyBullets = [], boss = null, bossBullets = [], explosions = [];
		let gameStarted = false, gameOver = false, bossSpawned = false, playerControlEnabled = true;
		let moveDir = null, startTime = 0, enemySpawner = null, autoShootTimer = null;
		let touchStartX = null;

		/* ========== キャンバスリサイズ ========== */
		function resizeCanvas() {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
		}
		window.addEventListener('resize', resizeCanvas);
		window.addEventListener('orientationchange', resizeCanvas);
		resizeCanvas();

		/* ========== プレイヤークラス ========== */
		class Player {
			constructor() {
				this.width = 30;
				this.height = 30;
				this.x = canvas.width / 2 - this.width / 2;
				this.y = canvas.height - 50;
				this.speed = 6;
				this.cooldown = 0;
			}
			update() {
				if (!playerControlEnabled) return;
				if (moveDir === "left" && this.x > 0) this.x -= this.speed;
				if (moveDir === "right" && this.x + this.width < canvas.width) this.x += this.speed;
				if (this.cooldown > 0) this.cooldown--;
			}
			draw() {
				ctx.fillStyle = "blue";
				ctx.fillRect(this.x, this.y, this.width, this.height);
			}
		}

		/* ========== プレイヤー弾 ========== */
		class Bullet {
			constructor(x, y) {
				this.x = x;
				this.y = y;
				this.width = 5;
				this.height = 10;
				this.speed = 8;
			}
			update() {this.y -= this.speed;}
			draw() {ctx.fillStyle = "red"; ctx.fillRect(this.x, this.y, this.width, this.height);}
		}

		/* ========== 敵 基底クラス ========== */
		class EnemyBase {
			constructor(color, width = 30, height = 30, hp = 1) {
				this.width = width;
				this.height = height;
				this.x = Math.random() * (canvas.width - this.width);
				this.y = -30;
				this.speed = 2;
				this.hp = hp;
				this.color = color;
			}
			hit() {
				this.hp--;
				return this.hp <= 0;
			}
			draw() {
				ctx.fillStyle = this.color;
				ctx.fillRect(this.x, this.y, this.width, this.height);
			}
		}

		/* ========== 敵タイプ1：通常 (既存) ========== */
		class EnemyType1 extends EnemyBase {
			constructor() {super("lime", 30, 30, 1);}
			update() {
				this.y += this.speed;
				if (Math.random() < 0.02) {
					enemyBullets.push(new EnemyBullet(this.x + this.width / 2, this.y + this.height));
				}
			}
		}

		/* ========== 敵タイプ2：ジグザグ (赤) ========== */
		class EnemyType2 extends EnemyBase {
			constructor() {
				super("red", 30, 30, 1);
				this.vx = Math.random() < 0.5 ? 2 : -2;
			}
			update() {
				this.y += this.speed;
				this.x += this.vx;
				if (this.x < 0 || this.x + this.width > canvas.width) this.vx *= -1;
			}
		}

		/* ========== 敵タイプ3：体力2 (紫) ========== */
		class EnemyType3 extends EnemyBase {
			constructor() {super("purple", 35, 35, 2);}
			update() {this.y += this.speed * 1.5;}
		}

		/* ========== 敵タイプ4：拡散弾 (水色) ========== */
		class EnemyType4 extends EnemyBase {
			constructor() {super("cyan", 30, 30, 1);}
			update() {
				this.y += this.speed;
				if (Math.random() < 0.01) {
					enemyBullets.push(new EnemyBullet(this.x, this.y, -2, 3));
					enemyBullets.push(new EnemyBullet(this.x + this.width / 2, this.y, 0, 4));
					enemyBullets.push(new EnemyBullet(this.x + this.width, this.y, 2, 3));
				}
			}
		}

		/* ========== ランダム敵出現関数 ========== */
		function spawnRandomEnemy() {
			const r = Math.floor(Math.random() * 4); // 0〜3
			let enemy;
			switch (r) {
				case 0: enemy = new EnemyType1(); break;
				case 1: enemy = new EnemyType2(); break;
				case 2: enemy = new EnemyType3(); break;
				case 3: enemy = new EnemyType4(); break;
			}
			enemies.push(enemy);
		}


		/* ========== 雑魚弾を拡張して方向指定可能にする ========== */
		class EnemyBullet {
			constructor(x, y, vx = 0, vy = 4) {
				this.x = x;
				this.y = y;
				this.vx = vx;
				this.vy = vy;
				this.width = 8;
				this.height = 8;
			}
			update() {
				this.x += this.vx;
				this.y += this.vy;
			}
			draw() {
				ctx.fillStyle = "yellow";
				ctx.fillRect(this.x, this.y, this.width, this.height);
			}
		}
		/* ========== 爆発エフェクト ========== */
		class Explosion {
			constructor(x, y) {
				this.x = x;
				this.y = y;
				this.r = 6;
				this.maxR = 40;
			}
			update() {this.r += 2;}
			draw() {
				ctx.beginPath();
				ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
				ctx.fillStyle = "orange";
				ctx.fill();
			}
		}

		/* ========== ボスクラス ========== */
		class Boss {
			constructor() {
				this.width = player.width * 3;
				this.height = 50;
				this.x = canvas.width / 2 - this.width / 2;
				this.y = 30;
				this.vx = 2;
				this.hp = 10;
				this.lastShot = 0;
				this.defeating = false;
				this.alpha = 1.0;
				this.defeatStartTime = 0;
			}
			update(time) {
				if (this.defeating) {
					const elapsed = time - this.defeatStartTime;
					const t = Math.min(elapsed / 3000, 1);
					this.y -= 0.6;
					this.alpha = 1 - t;
					if (Math.random() < 0.3) explosions.push(new Explosion(this.x + Math.random() * this.width, this.y + Math.random() * this.height));
					return;
				}
				this.x += this.vx;
				if (this.x < 0 || this.x + this.width > canvas.width) this.vx *= -1;
				if (time - this.lastShot >= 1000) {this.shootThree(); this.lastShot = time;}
			}
			draw() {
				ctx.save();
				ctx.globalAlpha = this.alpha;
				ctx.fillStyle = "blue";
				ctx.fillRect(this.x, this.y, this.width, this.height);
				ctx.fillStyle = "lime";
				ctx.fillRect((canvas.width - 200) / 2, 10, 200 * (this.hp / 10), 8);
				ctx.strokeStyle = "white";
				ctx.strokeRect((canvas.width - 200) / 2, 10, 200, 8);
				ctx.restore();
			}
			shootThree() {
				const cx = this.x + this.width / 2;
				const cy = this.y + this.height;
				bossBullets.push(new BossBullet(cx, cy, -2, 3));
				bossBullets.push(new BossBullet(cx, cy, 0, 4));
				bossBullets.push(new BossBullet(cx, cy, 2, 3));
			}
			hit() {
				if (this.defeating) return;
				this.hp--;
				if (this.hp <= 0) {
					this.defeating = true;
					this.defeatStartTime = performance.now();
					playerControlEnabled = false;
					enemies = [];
					enemyBullets = [];
					bossBullets = [];
					bullets = [];
					clearInterval(autoShootTimer);
					setTimeout(() => showGameClear(), 3000);
				}
			}
		}

		/* ========== ボス弾 ========== */
		class BossBullet {
			constructor(x, y, vx = 0, vy = 4) {
				this.x = x;
				this.y = y;
				this.vx = vx;
				this.vy = vy;
				this.width = 12;
				this.height = 12;
			}
			update() {
				this.x += this.vx;
				this.y += this.vy;
				if (this.x < 0 || this.x + this.width > canvas.width) this.vx *= -1;
			}
			draw() {ctx.fillStyle = "orange"; ctx.fillRect(this.x, this.y, this.width, this.height);}
		}

		/* ========== ゲーム管理 ========== */
		function startCountdown() {
			let t = 3;
			countdownEl.innerText = t;
			const timer = setInterval(() => {
				t--;
				if (t > 0) countdownEl.innerText = t;
				else if (t === 0) countdownEl.innerText = "START!";
				else {clearInterval(timer); countdownEl.style.display = "none"; startGame();}
			}, 1000);
		}



		function startGame() {
			player = new Player();
			gameStarted = true;
			startTime = Date.now();
			enemySpawner = setInterval(() => {
				if (!gameOver && !bossSpawned) spawnRandomEnemy();
			}, 1200);
			setTimeout(() => {if (!gameOver) spawnBoss();}, 10000);
			autoShootTimer = setInterval(() => {
				if (gameStarted && !gameOver && player) bullets.push(new Bullet(player.x + player.width / 2, player.y));
			}, 300);
			requestAnimationFrame(gameLoop);
		}

		function spawnBoss() {
			if (bossSpawned) return;
			bossSpawned = true;
			boss = new Boss();
		}

		function showGameClear() {
			gameOver = true;
			rewardBtn.style.display = "block";
			rewardBtn.onclick = () => {window.location.href = "Fade.html";};
		}

		function endGame() {
			if (!player) return;
			explosions.push(new Explosion(player.x + player.width / 2, player.y + player.height / 2));
			playerControlEnabled = false;
			setTimeout(() => {
				gameOver = true;
				retryBtn.style.display = "block";
				player = null;
			}, 500);
		}

		retryBtn.onclick = () => location.reload();
		rewardBtn.style.display = "none";

		/* ========== 入力処理 ========== */
		canvas.addEventListener("touchstart", e => {
			if (!gameStarted || gameOver || !player || !playerControlEnabled) return;
			touchStartX = e.touches[0].clientX;
			e.preventDefault();
		});
		canvas.addEventListener("touchmove", e => {
			if (!gameStarted || gameOver || !player || !playerControlEnabled) return;
			const currentX = e.touches[0].clientX;
			const dx = currentX - touchStartX;
			if (dx > 20) moveDir = "right";
			else if (dx < -20) moveDir = "left";
			else moveDir = null;
			e.preventDefault();
		});
		canvas.addEventListener("touchend", e => {
			moveDir = null;
			touchStartX = null;
		});
		document.addEventListener("keydown", e => {
			if (!gameStarted || gameOver || !player || !playerControlEnabled) return;
			if (e.key === "ArrowLeft") moveDir = "left";
			if (e.key === "ArrowRight") moveDir = "right";
		});
		document.addEventListener("keyup", e => {
			if (e.key === "ArrowLeft" && moveDir === "left") moveDir = null;
			if (e.key === "ArrowRight" && moveDir === "right") moveDir = null;
		});

		/* ========== メインループ ========== */
		function gameLoop(time) {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.fillStyle = "#111";
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			if (gameStarted) {
				if (player) {player.update(); player.draw();}
				for (let i = bullets.length - 1; i >= 0; i--) {
					const b = bullets[i];
					b.update(); b.draw();
					if (b.y + b.height < 0) {bullets.splice(i, 1); continue;}
					if (boss && !boss.defeating && b.x < boss.x + boss.width && b.x + b.width > boss.x &&
						b.y < boss.y + boss.height && b.y + b.height > boss.y) {
						bullets.splice(i, 1); boss.hit(); continue;
					}
				}
				for (let i = enemies.length - 1; i >= 0; i--) {
					const e = enemies[i];
					e.update(); e.draw();
					if (e.y > canvas.height) {enemies.splice(i, 1); continue;}
					if (player && player.x < e.x + e.width && player.x + player.width > e.x &&
						player.y < e.y + e.height && player.y + player.height > e.y) {endGame(); break;}
					for (let j = bullets.length - 1; j >= 0; j--) {
						const bb = bullets[j];
						if (bb.x < e.x + e.width && bb.x + bb.width > e.x &&
							bb.y < e.y + e.height && bb.y + bb.height > e.y) {
							// 当たった場合だけ
							if (e.hit()) enemies.splice(i, 1);
							bullets.splice(j, 1);
							break;
						}
					}

				}
				for (let i = enemyBullets.length - 1; i >= 0; i--) {
					const eb = enemyBullets[i];
					eb.update(); eb.draw();
					if (eb.y > canvas.height) {enemyBullets.splice(i, 1); continue;}
					if (player && player.x < eb.x + eb.width && player.x + player.width > eb.x &&
						player.y < eb.y + eb.height && player.y + player.height > eb.y) {endGame(); break;}
				}
				for (let i = bossBullets.length - 1; i >= 0; i--) {
					const bb = bossBullets[i];
					bb.update(); bb.draw();
					if (bb.y > canvas.height + 100) {bossBullets.splice(i, 1); continue;}
					if (player && player.x < bb.x + bb.width && player.x + player.width > bb.x &&
						player.y < bb.y + bb.height && player.y + bb.height > bb.y) {endGame(); break;}
				}
				for (let i = explosions.length - 1; i >= 0; i--) {
					explosions[i].update(); explosions[i].draw();
					if (explosions[i].r > explosions[i].maxR) explosions.splice(i, 1);
				}
				if (boss) {boss.update(time); boss.draw(); if (boss.defeating && boss.alpha <= 0.01) boss = null;}
			}
			ctx.fillStyle = "white";
			ctx.font = "30px Arial";
			ctx.textAlign = "center";
			if (rewardBtn.style.display === "block") ctx.fillText("Game Clear", canvas.width / 2, 60);
			else if (gameOver) ctx.fillText("Game Over", canvas.width / 2, 60);
			if (!gameOver || (rewardBtn.style.display === "block")) {
				requestAnimationFrame(gameLoop);
			}
		}

		/* ========== 初期化 ========== */
		window.onload = startCountdown;
	</script>
</body>

</html>